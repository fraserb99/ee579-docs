{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EE579 Group 4 Documentation # This site provides documentation to allow integration with our API and MQTT Broker. Read the Getting Started docs if you would like information on how to integrate your IoT device with our system. System Overview # Admin Interface # Our admin interface is available here: https://www.ee579-group4.net . This site enables users to login and configure rules, devices, and device groups. Our system is multi-tenant, with users able to create multiple tenants and invite other users. Rules and devices are then scoped to these tenants, meaning users only have permission to access and edit resources belonging one of their tenants. API # Our API is written in C# using ASP.NET Core. Full Swagger OpenAPI documentation is available here: https://ee579-dev-api.azurewebsites.net MQTT Broker # We are using Azure IoT Hub as our MQTT Broker. Information on connecting and recieving/publishing messages can be found here","title":"Home"},{"location":"#ee579-group-4-documentation","text":"This site provides documentation to allow integration with our API and MQTT Broker. Read the Getting Started docs if you would like information on how to integrate your IoT device with our system.","title":"EE579 Group 4 Documentation"},{"location":"#system-overview","text":"","title":"System Overview"},{"location":"#admin-interface","text":"Our admin interface is available here: https://www.ee579-group4.net . This site enables users to login and configure rules, devices, and device groups. Our system is multi-tenant, with users able to create multiple tenants and invite other users. Rules and devices are then scoped to these tenants, meaning users only have permission to access and edit resources belonging one of their tenants.","title":"Admin Interface"},{"location":"#api","text":"Our API is written in C# using ASP.NET Core. Full Swagger OpenAPI documentation is available here: https://ee579-dev-api.azurewebsites.net","title":"API"},{"location":"#mqtt-broker","text":"We are using Azure IoT Hub as our MQTT Broker. Information on connecting and recieving/publishing messages can be found here","title":"MQTT Broker"},{"location":"admin-interface/","text":"Admin Interface #","title":"Admin Interface"},{"location":"admin-interface/#admin-interface","text":"","title":"Admin Interface"},{"location":"create-account/","text":"Create an Account # Visit https://www.ee579-group4.net/signup to get started. There are several methods available for signing in: Username and Password # To create an account with a username and password, fill out the form on the sign up page. You will then be sent an email to verify that you have access to the email address. You must then click the link in the email before you can sign in. External Providers # Logging in with an external provider allows you to reduce the number of passwords and accounts you have to manage. This site allows you to sign in with your Google or Microsoft account. Click the respective button to start the external sign in process. You will then be redirected to the external providers site where you can sign in. After signing in to the external providers account, you will be redirected back to this site and signed in. Verifying your email is not required when using external sign in as signing into the account verifies that you have access to the email. Next Steps # Learn about how Multi-Tenancy works in this application","title":"Creating an Account"},{"location":"create-account/#create-an-account","text":"Visit https://www.ee579-group4.net/signup to get started. There are several methods available for signing in:","title":"Create an Account"},{"location":"create-account/#username-and-password","text":"To create an account with a username and password, fill out the form on the sign up page. You will then be sent an email to verify that you have access to the email address. You must then click the link in the email before you can sign in.","title":"Username and Password"},{"location":"create-account/#external-providers","text":"Logging in with an external provider allows you to reduce the number of passwords and accounts you have to manage. This site allows you to sign in with your Google or Microsoft account. Click the respective button to start the external sign in process. You will then be redirected to the external providers site where you can sign in. After signing in to the external providers account, you will be redirected back to this site and signed in. Verifying your email is not required when using external sign in as signing into the account verifies that you have access to the email.","title":"External Providers"},{"location":"create-account/#next-steps","text":"Learn about how Multi-Tenancy works in this application","title":"Next Steps"},{"location":"devices/","text":"Devices # Devices are the devices that will be used in rules. They send inputs to the API and receive messages to perform outputs. Adding Devices # Before devices can be used to create rules, they must be claimed by a tenant. The first step is to power the device on. When powered on for the first time, the device will register itself with the system, making it possible to claim it in the web interface. After the device has been powered on, navigatet to the devices page and click the add button above the table. This shows the modal below. This shows the devices available for you to claim. You must be on the same network as a device in order to claim it. This prevents other users from claiming devices that do not belong to them. The devices are listed by their MAC address which you may use to identify specific devices when multiple are available. If you do not know the MAC address of your device you can press the lightbulb button. This will flash an LED on the device for 5 seconds, allwoing you to identify which device the list item corresponds to. To claim a device press the add button next to its MAC address. This will bring up a form allowing you to give the device a user friendly name before claiming it. Managing Existing Devices # After devices have been added, they will be visible on the devices page as shown below. This page allows you to view all of your devices and their current state. The 'Connection State' column shows whether the device is currently connected to the MQTT broker and able to send and receive inputs and outputs. It also allows you to preform some actions on the device. Here you may identify a device in the same way as when claiming it, by pressing the LED button. You can also change the device's name and unclaim it from the current tenant. Unclaiming a Device # You may wish to unclaim a device from a tenant. This removes the device from its current tenant, and removes it from any rules it may have been involved in. This does not delete the device completely, only resets it, allowing it to be claimed by another tenant. If you want to move a device from one tenant to another this would be the way of doing that. Device Groups # Device groups provide a method of grouping devices with similar functions to improve the process of adding and managing rules. Device groups can be added by specifying a name, and list of devices that should be long to the group. The name and devices can also be edited later. Next Steps # Find out how Rules work","title":"Managing Devices"},{"location":"devices/#devices","text":"Devices are the devices that will be used in rules. They send inputs to the API and receive messages to perform outputs.","title":"Devices"},{"location":"devices/#adding-devices","text":"Before devices can be used to create rules, they must be claimed by a tenant. The first step is to power the device on. When powered on for the first time, the device will register itself with the system, making it possible to claim it in the web interface. After the device has been powered on, navigatet to the devices page and click the add button above the table. This shows the modal below. This shows the devices available for you to claim. You must be on the same network as a device in order to claim it. This prevents other users from claiming devices that do not belong to them. The devices are listed by their MAC address which you may use to identify specific devices when multiple are available. If you do not know the MAC address of your device you can press the lightbulb button. This will flash an LED on the device for 5 seconds, allwoing you to identify which device the list item corresponds to. To claim a device press the add button next to its MAC address. This will bring up a form allowing you to give the device a user friendly name before claiming it.","title":"Adding Devices"},{"location":"devices/#managing-existing-devices","text":"After devices have been added, they will be visible on the devices page as shown below. This page allows you to view all of your devices and their current state. The 'Connection State' column shows whether the device is currently connected to the MQTT broker and able to send and receive inputs and outputs. It also allows you to preform some actions on the device. Here you may identify a device in the same way as when claiming it, by pressing the LED button. You can also change the device's name and unclaim it from the current tenant.","title":"Managing Existing Devices"},{"location":"devices/#unclaiming-a-device","text":"You may wish to unclaim a device from a tenant. This removes the device from its current tenant, and removes it from any rules it may have been involved in. This does not delete the device completely, only resets it, allowing it to be claimed by another tenant. If you want to move a device from one tenant to another this would be the way of doing that.","title":"Unclaiming a Device"},{"location":"devices/#device-groups","text":"Device groups provide a method of grouping devices with similar functions to improve the process of adding and managing rules. Device groups can be added by specifying a name, and list of devices that should be long to the group. The name and devices can also be edited later.","title":"Device Groups"},{"location":"devices/#next-steps","text":"Find out how Rules work","title":"Next Steps"},{"location":"getting-started/","text":"Getting Started # Requirements #","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#requirements","text":"","title":"Requirements"},{"location":"mqtt-schema/","text":"MQTT Messaging Schema # Device to Cloud Messages # Button Pushed # This message is sent to the broker whenever a button is pushed on the microcontroller. Message Body : { \"InputType\": enum, // [Button1, Button2] \"Duration\": int // The length the button is held in ms } Potentiometer Input # This message is sent every time the analogue value from the potentiometer is read. The value is sent with this message. Message Body : { \"InputType\": \"PotentiometerValue\" \"Value\": int // (0 - 1023) - the analogue value of the potentiometer } Temperature Input # This message is sent every time the analogue value from the temperature sensor is read. The value is sent with this message. Message Body : { \"InputType\"=\"PotentiometerValue\" \"Value\": int // (-50 to 100) - the degrees celcius read from the temperature sensor } Cloud to Device Messages # LED Output # This message is sent to notify the microcontroller to turn an LED on/off and with the specified colour. Message Body : { \"OutputType\": \"LedOutput\", \"Peripheral\": enum, // [Led1, Led2, Led3] \"Value\": bool, // the desired state of the LED. \"Colour\" enum // (Led3 only): [Red/Green/Blue/Purple/Yellow/White] } Breath LED # This message is sent to notify the microcontroller to breathe an LED at a specified speed and colour. Message Body : { \"OutputType\": \"LedBreathe\", \"Peripheral\": enum, // [Led1, Led2, Led3] \"Period\": int, // how long the period of the breathing should be in ms. \"Colour\": enum // (Led3 only): [Red/Green/Blue/Purple/Yellow/White] } Blink LED # This message is sent to notify the microcontroller to blink an LED at a specified speed and colour. Message Body : { \"OutputType\": \"LedBlink\", \"Peripheral\": enum, // [Led1, Led2, Led3] \"Period\": int, // how long the period of the blinking should be in ms. \"Colour\": enum // (Led3 only): [Red/Green/Blue/Purple/Yellow/White] } Fade LED # This message is sent to notify the microcontroller to fade an LED to a desired state at a specified speed and colour. Message Body : { \"OutputType\"=\"LedFade\", \"Peripheral\": enum, // [Led1, Led2, Led3] \"Value\": bool, // the desired state of the LED. \"Duration\": int, // the duration the fade should take in ms. \"Colour\": enum // (Led3 only): [Red/Green/Blue/Purple/Yellow/White] } Cycle LED 3 # This message is sent to notify the microcontroller to cycle the LED colour in the specified direction. Message Body : { \"OutputType\": \"LedCycle\", \"Direction\": bool, // cycle forwards or backwards -forwards = true \"Period\": int // how long the period of the cycle should be in ms } Buzzer On # This message is sent to notify the microcontroller to turn the piezo buzzer on for the specified length of time. Message Body : { \"OutputType\": \"BuzzerOn\" \"Duration\": int, // the duration the buzzer should be on in ms } Beep Buzzer # This message is sent to make the microcontroller toggle a buzzer at the desired rate. Message Body : { \"OutputType\": \"BuzzerBeep\" \"OnDuration\": int // the duration the buzzer should be on in ms \"OffDuration\": int // the duration the buzzer should be off in ms } Configure Device # This message is sent to notify the microcontroller which input devices are involved in rules. This is used to limit the number of messages sent by devices - if an input device is not involved in any rules, messages should not be sent to the broker when its value changes Message Body : { \"MessageType\": \"DeviceConfig\" \"Button1\": bool \"Button2\": bool \"Potentiometer\": bool \"Temperature\": bool }","title":"Messaging Schema"},{"location":"mqtt-schema/#mqtt-messaging-schema","text":"","title":"MQTT Messaging Schema"},{"location":"mqtt-schema/#device-to-cloud-messages","text":"","title":"Device to Cloud Messages"},{"location":"mqtt-schema/#button-pushed","text":"This message is sent to the broker whenever a button is pushed on the microcontroller. Message Body : { \"InputType\": enum, // [Button1, Button2] \"Duration\": int // The length the button is held in ms }","title":"Button Pushed"},{"location":"mqtt-schema/#potentiometer-input","text":"This message is sent every time the analogue value from the potentiometer is read. The value is sent with this message. Message Body : { \"InputType\": \"PotentiometerValue\" \"Value\": int // (0 - 1023) - the analogue value of the potentiometer }","title":"Potentiometer Input"},{"location":"mqtt-schema/#temperature-input","text":"This message is sent every time the analogue value from the temperature sensor is read. The value is sent with this message. Message Body : { \"InputType\"=\"PotentiometerValue\" \"Value\": int // (-50 to 100) - the degrees celcius read from the temperature sensor }","title":"Temperature Input"},{"location":"mqtt-schema/#cloud-to-device-messages","text":"","title":"Cloud to Device Messages"},{"location":"mqtt-schema/#led-output","text":"This message is sent to notify the microcontroller to turn an LED on/off and with the specified colour. Message Body : { \"OutputType\": \"LedOutput\", \"Peripheral\": enum, // [Led1, Led2, Led3] \"Value\": bool, // the desired state of the LED. \"Colour\" enum // (Led3 only): [Red/Green/Blue/Purple/Yellow/White] }","title":"LED Output"},{"location":"mqtt-schema/#breath-led","text":"This message is sent to notify the microcontroller to breathe an LED at a specified speed and colour. Message Body : { \"OutputType\": \"LedBreathe\", \"Peripheral\": enum, // [Led1, Led2, Led3] \"Period\": int, // how long the period of the breathing should be in ms. \"Colour\": enum // (Led3 only): [Red/Green/Blue/Purple/Yellow/White] }","title":"Breath LED"},{"location":"mqtt-schema/#blink-led","text":"This message is sent to notify the microcontroller to blink an LED at a specified speed and colour. Message Body : { \"OutputType\": \"LedBlink\", \"Peripheral\": enum, // [Led1, Led2, Led3] \"Period\": int, // how long the period of the blinking should be in ms. \"Colour\": enum // (Led3 only): [Red/Green/Blue/Purple/Yellow/White] }","title":"Blink LED"},{"location":"mqtt-schema/#fade-led","text":"This message is sent to notify the microcontroller to fade an LED to a desired state at a specified speed and colour. Message Body : { \"OutputType\"=\"LedFade\", \"Peripheral\": enum, // [Led1, Led2, Led3] \"Value\": bool, // the desired state of the LED. \"Duration\": int, // the duration the fade should take in ms. \"Colour\": enum // (Led3 only): [Red/Green/Blue/Purple/Yellow/White] }","title":"Fade LED"},{"location":"mqtt-schema/#cycle-led-3","text":"This message is sent to notify the microcontroller to cycle the LED colour in the specified direction. Message Body : { \"OutputType\": \"LedCycle\", \"Direction\": bool, // cycle forwards or backwards -forwards = true \"Period\": int // how long the period of the cycle should be in ms }","title":"Cycle LED 3"},{"location":"mqtt-schema/#buzzer-on","text":"This message is sent to notify the microcontroller to turn the piezo buzzer on for the specified length of time. Message Body : { \"OutputType\": \"BuzzerOn\" \"Duration\": int, // the duration the buzzer should be on in ms }","title":"Buzzer On"},{"location":"mqtt-schema/#beep-buzzer","text":"This message is sent to make the microcontroller toggle a buzzer at the desired rate. Message Body : { \"OutputType\": \"BuzzerBeep\" \"OnDuration\": int // the duration the buzzer should be on in ms \"OffDuration\": int // the duration the buzzer should be off in ms }","title":"Beep Buzzer"},{"location":"mqtt-schema/#configure-device","text":"This message is sent to notify the microcontroller which input devices are involved in rules. This is used to limit the number of messages sent by devices - if an input device is not involved in any rules, messages should not be sent to the broker when its value changes Message Body : { \"MessageType\": \"DeviceConfig\" \"Button1\": bool \"Button2\": bool \"Potentiometer\": bool \"Temperature\": bool }","title":"Configure Device"},{"location":"mqtt/","text":"MQTT Broker # Connecting # To connect to IoTHub there are multiple different protocols that can be used, you can either directly connect to these protocols or prefferably use one of the IoTHub device SDKs. Connecting using the IotHub SDKs # Connecting to IoTHub using one of Microsoft's SDKs use a connection string to connect. The connection string can be garnered from the response from our API's register request. Using the SDKs is the recommended way of connecting for its ease of use, especially regarding certificate handling as IoTHub forces TLS/SSL. Some of the available SDKs include: C SDK Python SDK Node.js SDK Java SDK .NET SDK Using our Example Code for an ESP8266 # We have provided some example code for registering a device with the API and sending/receiving messages from IoTHub. This example code is for the ESP8266 Wifi Module, but the methods will be similar on alternative devices. The code can be pulled from this repository . Cd into the esp_iothub_client directory for the example code. By following the instructions here , you can setup the Arduino IDE with functionality for flashing our example code to the ESP8266. Connecting directly to the protocols # As MQTT is usually implemented on memory restricted devices, it is possible that the memory required to implement broker connection/interaction using an SDK is unavailable. For this reason, directly connecting to the protocol might be required. Below is a mosquitto subscribe command showing the parameters required to manually connect to the cloud device topic. mosquitto_sub \\ -h IFTTT-Iot-Hub.azure-devices.net \\ -p 8883 \\ -t \"devices/00:0a:95:9d:68:16/messages/devicebound/#\" \\ -i 00:0a:95:9d:68:16 \\ -u \"IFTTT-Iot-Hub.azure-devices.net/00:0a:95:9d:68:16\" \\ -P \"SharedAccessSignature sr=IFTTT-Iot-Hub.azure-devices.net%2Fdevices%2F00%3A0a%3A95%3A9d%3A68%3A16&sig=ulc08e%2FYp%2FMLJdyMLxsV7pqTQ12XamytzQjxFFithNg%3D&se=1618623078\" \\ --cafile C:\\Users\\Fraser\\GitHub\\ee579-api\\EE579\\EE579.Core\\Slices\\Devices\\Simulate\\iotHubCert.pem -d -V mqttv311 -q 1 -h : The host name for the broker. -p : The port number of the broker. -t : The topic the cloud to device messages will be received on. -i : The unique identifier for the device. Recommended as the device MAC address. -u : The MQTT username which here is just set to the hostname/deviceId. -P : The password for the broker. Can be retrieved from the register API response. --catfile : Path to the IotHub Certificate. -V : The MQTT version. IotHub only supports MQTT version 3.1.1. -q : This is for the quality of service. IoTHub only supports a quality service of 1.","title":"Connecting to the broker"},{"location":"mqtt/#mqtt-broker","text":"","title":"MQTT Broker"},{"location":"mqtt/#connecting","text":"To connect to IoTHub there are multiple different protocols that can be used, you can either directly connect to these protocols or prefferably use one of the IoTHub device SDKs.","title":"Connecting"},{"location":"mqtt/#connecting-using-the-iothub-sdks","text":"Connecting to IoTHub using one of Microsoft's SDKs use a connection string to connect. The connection string can be garnered from the response from our API's register request. Using the SDKs is the recommended way of connecting for its ease of use, especially regarding certificate handling as IoTHub forces TLS/SSL. Some of the available SDKs include: C SDK Python SDK Node.js SDK Java SDK .NET SDK","title":"Connecting using the IotHub SDKs"},{"location":"mqtt/#using-our-example-code-for-an-esp8266","text":"We have provided some example code for registering a device with the API and sending/receiving messages from IoTHub. This example code is for the ESP8266 Wifi Module, but the methods will be similar on alternative devices. The code can be pulled from this repository . Cd into the esp_iothub_client directory for the example code. By following the instructions here , you can setup the Arduino IDE with functionality for flashing our example code to the ESP8266.","title":"Using our Example Code for an ESP8266"},{"location":"mqtt/#connecting-directly-to-the-protocols","text":"As MQTT is usually implemented on memory restricted devices, it is possible that the memory required to implement broker connection/interaction using an SDK is unavailable. For this reason, directly connecting to the protocol might be required. Below is a mosquitto subscribe command showing the parameters required to manually connect to the cloud device topic. mosquitto_sub \\ -h IFTTT-Iot-Hub.azure-devices.net \\ -p 8883 \\ -t \"devices/00:0a:95:9d:68:16/messages/devicebound/#\" \\ -i 00:0a:95:9d:68:16 \\ -u \"IFTTT-Iot-Hub.azure-devices.net/00:0a:95:9d:68:16\" \\ -P \"SharedAccessSignature sr=IFTTT-Iot-Hub.azure-devices.net%2Fdevices%2F00%3A0a%3A95%3A9d%3A68%3A16&sig=ulc08e%2FYp%2FMLJdyMLxsV7pqTQ12XamytzQjxFFithNg%3D&se=1618623078\" \\ --cafile C:\\Users\\Fraser\\GitHub\\ee579-api\\EE579\\EE579.Core\\Slices\\Devices\\Simulate\\iotHubCert.pem -d -V mqttv311 -q 1 -h : The host name for the broker. -p : The port number of the broker. -t : The topic the cloud to device messages will be received on. -i : The unique identifier for the device. Recommended as the device MAC address. -u : The MQTT username which here is just set to the hostname/deviceId. -P : The password for the broker. Can be retrieved from the register API response. --catfile : Path to the IotHub Certificate. -V : The MQTT version. IotHub only supports MQTT version 3.1.1. -q : This is for the quality of service. IoTHub only supports a quality service of 1.","title":"Connecting directly to the protocols"},{"location":"multi-tenancy/","text":"Multi-Tenancy # What is Multi-Tenancy? # Multi-tenancy is an architecture that allows a single application to be used by multiple customers. This means that data in the application is scoped to the current customer and not visible to other customers of the application. An example of this is rhe university's use of Microsoft's suite of applications. In this case, the university has their own tenant. This tenant contains all of the data specific Multi-Tenancy in this application # Multi-tenancy in this application involves scoping rules, devices, and device groups to tenants. This allows multiple customers to use the application without other customers seeing their data. Users can then belong to multiple tenants, allowing them to view and manage their data. Creating a Tenant # When first creating an account a new tenant is created for you, allowing you to get started creating rules and adding devices. You may want to add another tenant in order to keep unrelated data separate - e.g., keeping rules and devices for each building in their own tenant. This can be done by clicking the 'Switch Tenant' button in the left drawer and then selecting 'Create a new tenant'. Next Steps # Learn how to manage users within tenants Find out how to add and manage devices","title":"Multi-Tenancy"},{"location":"multi-tenancy/#multi-tenancy","text":"","title":"Multi-Tenancy"},{"location":"multi-tenancy/#what-is-multi-tenancy","text":"Multi-tenancy is an architecture that allows a single application to be used by multiple customers. This means that data in the application is scoped to the current customer and not visible to other customers of the application. An example of this is rhe university's use of Microsoft's suite of applications. In this case, the university has their own tenant. This tenant contains all of the data specific","title":"What is Multi-Tenancy?"},{"location":"multi-tenancy/#multi-tenancy-in-this-application","text":"Multi-tenancy in this application involves scoping rules, devices, and device groups to tenants. This allows multiple customers to use the application without other customers seeing their data. Users can then belong to multiple tenants, allowing them to view and manage their data.","title":"Multi-Tenancy in this application"},{"location":"multi-tenancy/#creating-a-tenant","text":"When first creating an account a new tenant is created for you, allowing you to get started creating rules and adding devices. You may want to add another tenant in order to keep unrelated data separate - e.g., keeping rules and devices for each building in their own tenant. This can be done by clicking the 'Switch Tenant' button in the left drawer and then selecting 'Create a new tenant'.","title":"Creating a Tenant"},{"location":"multi-tenancy/#next-steps","text":"Learn how to manage users within tenants Find out how to add and manage devices","title":"Next Steps"},{"location":"register-device/","text":"Getting Started # Registering a device # In order for your device to connect to IoT Hub, it must first retreive credentials. This can be done by sending a POST request to https://ee579-dev-api.azurewebsites.net/devices/register . This will register your device with our system and return credentials to allow connection over MQTT. The device should make this request when first powered on, but the same endpoint can be used even if a device is already registered in the system. This accounts for situations where the device may have lost it's credentials, and allows the device to make the request every time it powers on, if desired. Request Format # Example Body # { \"deviceId\": \"<string>\" } Parameters # deviceId : This should be a unique identifier. A MAC adress is recommended, but it can take any form - guid, uuid, etc. Response Format # Example Body # { \"connectionString\": \"HostName=IFTTT-Iot-Hub.azure-devices.net;DeviceId={deviceId};SharedAccessKey=El50EkQ/S/9qp5dd/V3VpsizIvSv+SA8TVF3QiGc93A=\", \"host\": \"IFTTT-Iot-Hub.azure-devices.net\", \"port\": 8883, \"topic\": \"devices/{deviceId}/messages/devicebound/#\", \"password\": \"SharedAccessSignature sr=IFTTT-Iot-Hub.azure-devices.net%2Fdevices%2F{deviceId}&sig=KOYS9LgCJ9eH7TTlMIGvedxIVI3cXmha7uU6yB4Bs6M%3D&se=88018657115\" } Parameters # connectionString : The connection string the broker. {deviceId} should be replace with a unique identifier. A MAC adress is recommended, but it can take any form - guid, uuid, etc. host : The MQTT broker url. topic : The topic that the device should subscribe to, to receive cloud-to-device messages. password : The password that should be used when connecting to the broker, in the form of a SAS token . Debugging # It may be neccessary to make this request on a computer, rather than IoT device when debugging. The API Swagger Docs can be used to make this request and provides a prefilled request body. Any other method of making HTTP requests can also be used - cURL, Postman , etc. Next Steps # Connecting to the broker","title":"Registering a Device"},{"location":"register-device/#getting-started","text":"","title":"Getting Started"},{"location":"register-device/#registering-a-device","text":"In order for your device to connect to IoT Hub, it must first retreive credentials. This can be done by sending a POST request to https://ee579-dev-api.azurewebsites.net/devices/register . This will register your device with our system and return credentials to allow connection over MQTT. The device should make this request when first powered on, but the same endpoint can be used even if a device is already registered in the system. This accounts for situations where the device may have lost it's credentials, and allows the device to make the request every time it powers on, if desired.","title":"Registering a device"},{"location":"register-device/#request-format","text":"","title":"Request Format"},{"location":"register-device/#example-body","text":"{ \"deviceId\": \"<string>\" }","title":"Example Body"},{"location":"register-device/#parameters","text":"deviceId : This should be a unique identifier. A MAC adress is recommended, but it can take any form - guid, uuid, etc.","title":"Parameters"},{"location":"register-device/#response-format","text":"","title":"Response Format"},{"location":"register-device/#example-body_1","text":"{ \"connectionString\": \"HostName=IFTTT-Iot-Hub.azure-devices.net;DeviceId={deviceId};SharedAccessKey=El50EkQ/S/9qp5dd/V3VpsizIvSv+SA8TVF3QiGc93A=\", \"host\": \"IFTTT-Iot-Hub.azure-devices.net\", \"port\": 8883, \"topic\": \"devices/{deviceId}/messages/devicebound/#\", \"password\": \"SharedAccessSignature sr=IFTTT-Iot-Hub.azure-devices.net%2Fdevices%2F{deviceId}&sig=KOYS9LgCJ9eH7TTlMIGvedxIVI3cXmha7uU6yB4Bs6M%3D&se=88018657115\" }","title":"Example Body"},{"location":"register-device/#parameters_1","text":"connectionString : The connection string the broker. {deviceId} should be replace with a unique identifier. A MAC adress is recommended, but it can take any form - guid, uuid, etc. host : The MQTT broker url. topic : The topic that the device should subscribe to, to receive cloud-to-device messages. password : The password that should be used when connecting to the broker, in the form of a SAS token .","title":"Parameters"},{"location":"register-device/#debugging","text":"It may be neccessary to make this request on a computer, rather than IoT device when debugging. The API Swagger Docs can be used to make this request and provides a prefilled request body. Any other method of making HTTP requests can also be used - cURL, Postman , etc.","title":"Debugging"},{"location":"register-device/#next-steps","text":"Connecting to the broker","title":"Next Steps"},{"location":"rules/","text":"Rules # Rules are the core functionality of the system, allowing inputs from devices to trigger outputs. Creating Rules # Navigate to the rules page and press the add button to create a new rule. The rule form is shown below: The form is composed of 3 sections: Name, Trigger, and Outputs. Trigger # The Rule trigger is the device input that will trigger the rule and cause the outputs to be performed. This is composed of the input type and parameters desired, and the device or device group the input will come from. If a device group is chosen, an input matching the desired type and parameters from any of the groups devices will trigger the rule. There are several input types that can be chosen: Input Types # Button Pushed # This input is sent when the button is pushed on a device. The duration desired to trigger the rule can be set to one of three values: Short Press - 0s < 2s Medium Press - 2s < 10s Long Press - > 10s Switch Flipped # This input allows rules to be triggered when one of the 2 switches on the device are flipped. The peripheral (switch 1 or 2) can be chosen and the switch state. The switch state is used to specify whether the switch should be triggered when the switch is flipped to an on or off state. Potentiometer # This input allows you to specify a range of potentiometer values that will trigger the rule. The default configuration is a range between two values but this can also be inverted to allow for specifying a range of values less than the lower value or greater than the higher value. This can be done by pressing the button between the values, or manually setting the greater than value to be higher than the less than. When using a potentiometer value as an input it should be noted that the rule will not be triggered every time the potentiometer value changes if it is within the trigger range. Instead, the system keeps track of the last potentiometer value sent by the device and only triggers the rule if the last value was outwith the range and the new value is within it. Temperature # This input allows you to use the temperature sensor on your device as a trigger for the rule. It functions in a similar way to the potentiometer trigger, with a range picker. Again this range can be inverted, and the rule is only triggered when the last value did not satisfy the conditions. Web Hooks # This is an input that can be triggered via the invocation of a generated URL, commonly known as a web hook. It works similar to a physical input such as a button press, but instead of being triggered upon the button being pressed, the trigger happens upon invocation of the URL. After adding a rule with a web hook as an input, from the rules page on the website, find the added rule from which the invoke URL can be garnered. Below is an example of what this looks like. For more information for developers and using web hooks for interoperability please see here . Outputs # These are the outputs that will be performed when a rule is triggered. Multiple outputs can be performed for each rule. Output Types # Buzzer - On # This output is used to sound a continuous buzzer tone for the specified duration. Buzzer - Beep # This output beeps the buzzer with the duty cycle specified. The minimum values for the on and off duration are 200ms. LED - Output # This output can be used to turn an LED on or off. There are 3 LEDs that can be selected, corresponding to the LEDs on the MSP430G2553. As such, LEDs 1 and 2 are single colour, but a colour - Red, Green, Blue, Purple, Yellow, White - can be chosen when LED 3 is selected. This choice of colour also applies to the other output types involving LED 3. LED - Blink # This output blinks the LED with the specified period. LED - Breathe # This output makes the LED 'breathe' by smoothly changing the brightness from zero to full brightness and back again, and then repeats. The period of this breathing can be configured. LED - Fade # This output fades the LED off over a given period of time. LED - Cycle # This output applies only to LED 3 as it cycles through all possible colours. The direction of the cycle can be chosen along with the period - the total amount of time it will take to cycle through all colours","title":"Rules"},{"location":"rules/#rules","text":"Rules are the core functionality of the system, allowing inputs from devices to trigger outputs.","title":"Rules"},{"location":"rules/#creating-rules","text":"Navigate to the rules page and press the add button to create a new rule. The rule form is shown below: The form is composed of 3 sections: Name, Trigger, and Outputs.","title":"Creating Rules"},{"location":"rules/#trigger","text":"The Rule trigger is the device input that will trigger the rule and cause the outputs to be performed. This is composed of the input type and parameters desired, and the device or device group the input will come from. If a device group is chosen, an input matching the desired type and parameters from any of the groups devices will trigger the rule. There are several input types that can be chosen:","title":"Trigger"},{"location":"rules/#input-types","text":"","title":"Input Types"},{"location":"rules/#button-pushed","text":"This input is sent when the button is pushed on a device. The duration desired to trigger the rule can be set to one of three values: Short Press - 0s < 2s Medium Press - 2s < 10s Long Press - > 10s","title":"Button Pushed"},{"location":"rules/#switch-flipped","text":"This input allows rules to be triggered when one of the 2 switches on the device are flipped. The peripheral (switch 1 or 2) can be chosen and the switch state. The switch state is used to specify whether the switch should be triggered when the switch is flipped to an on or off state.","title":"Switch Flipped"},{"location":"rules/#potentiometer","text":"This input allows you to specify a range of potentiometer values that will trigger the rule. The default configuration is a range between two values but this can also be inverted to allow for specifying a range of values less than the lower value or greater than the higher value. This can be done by pressing the button between the values, or manually setting the greater than value to be higher than the less than. When using a potentiometer value as an input it should be noted that the rule will not be triggered every time the potentiometer value changes if it is within the trigger range. Instead, the system keeps track of the last potentiometer value sent by the device and only triggers the rule if the last value was outwith the range and the new value is within it.","title":"Potentiometer"},{"location":"rules/#temperature","text":"This input allows you to use the temperature sensor on your device as a trigger for the rule. It functions in a similar way to the potentiometer trigger, with a range picker. Again this range can be inverted, and the rule is only triggered when the last value did not satisfy the conditions.","title":"Temperature"},{"location":"rules/#web-hooks","text":"This is an input that can be triggered via the invocation of a generated URL, commonly known as a web hook. It works similar to a physical input such as a button press, but instead of being triggered upon the button being pressed, the trigger happens upon invocation of the URL. After adding a rule with a web hook as an input, from the rules page on the website, find the added rule from which the invoke URL can be garnered. Below is an example of what this looks like. For more information for developers and using web hooks for interoperability please see here .","title":"Web Hooks"},{"location":"rules/#outputs","text":"These are the outputs that will be performed when a rule is triggered. Multiple outputs can be performed for each rule.","title":"Outputs"},{"location":"rules/#output-types","text":"","title":"Output Types"},{"location":"rules/#buzzer-on","text":"This output is used to sound a continuous buzzer tone for the specified duration.","title":"Buzzer - On"},{"location":"rules/#buzzer-beep","text":"This output beeps the buzzer with the duty cycle specified. The minimum values for the on and off duration are 200ms.","title":"Buzzer - Beep"},{"location":"rules/#led-output","text":"This output can be used to turn an LED on or off. There are 3 LEDs that can be selected, corresponding to the LEDs on the MSP430G2553. As such, LEDs 1 and 2 are single colour, but a colour - Red, Green, Blue, Purple, Yellow, White - can be chosen when LED 3 is selected. This choice of colour also applies to the other output types involving LED 3.","title":"LED - Output"},{"location":"rules/#led-blink","text":"This output blinks the LED with the specified period.","title":"LED - Blink"},{"location":"rules/#led-breathe","text":"This output makes the LED 'breathe' by smoothly changing the brightness from zero to full brightness and back again, and then repeats. The period of this breathing can be configured.","title":"LED - Breathe"},{"location":"rules/#led-fade","text":"This output fades the LED off over a given period of time.","title":"LED - Fade"},{"location":"rules/#led-cycle","text":"This output applies only to LED 3 as it cycles through all possible colours. The direction of the cycle can be chosen along with the period - the total amount of time it will take to cycle through all colours","title":"LED - Cycle"},{"location":"users/","text":"Users # Roles # Users can have one of two roles within a tenant: User - Users with this role can manage devices, rules, and device groups. However, they cannot manage users belonging to the tenant or edit the tenant itself. Owner - This user has full control over the tenant. They can manage everything a user can, along with inviting and removing users and editing the tenant. Inviting Users # Users can be invited to tenants by their email address. If the user already has an account, they will have immediate access to the tenant and receive an email telling them that they have been invited to your tenant. If they have not yet created an account they will receive an email informing them they have been invited to your tenant, including a link to sign up.","title":"Managing Users"},{"location":"users/#users","text":"","title":"Users"},{"location":"users/#roles","text":"Users can have one of two roles within a tenant: User - Users with this role can manage devices, rules, and device groups. However, they cannot manage users belonging to the tenant or edit the tenant itself. Owner - This user has full control over the tenant. They can manage everything a user can, along with inviting and removing users and editing the tenant.","title":"Roles"},{"location":"users/#inviting-users","text":"Users can be invited to tenants by their email address. If the user already has an account, they will have immediate access to the tenant and receive an email telling them that they have been invited to your tenant. If they have not yet created an account they will receive an email informing them they have been invited to your tenant, including a link to sign up.","title":"Inviting Users"},{"location":"webhooks/","text":"Web Hooks # Interopability # In essence, our web hook functionality allows our system to be controlled by a completely different system, assuming that the different system is capable of sending HTTP post requests. That is, a rule from any connected device on our system, can be triggered by invoking the web hook URL that we give generate by sending a post request to it. This gives almost limitless potential for input interoperability thereby making our system not being subject to the hardware limitations on certain microncontrollers such as the","title":"Web Hooks"},{"location":"webhooks/#web-hooks","text":"","title":"Web Hooks"},{"location":"webhooks/#interopability","text":"In essence, our web hook functionality allows our system to be controlled by a completely different system, assuming that the different system is capable of sending HTTP post requests. That is, a rule from any connected device on our system, can be triggered by invoking the web hook URL that we give generate by sending a post request to it. This gives almost limitless potential for input interoperability thereby making our system not being subject to the hardware limitations on certain microncontrollers such as the","title":"Interopability"}]}